<html>

<body>

<pre>
TODO: highlight.js
</pre>

<pre>

0. Cover slide for screen before talk: a "beautiful destination" picture chosen by neural net?

1. Intro - me, BD. contact details.
 - not talk too much about BD specifically because my talk is more about the more general things I've encountered,
   though there will be some details about what we do in the talk because its not secret secret.

2. describing existing processes in shake

The environment when I arrived:
 * core haskell product built by Makefile and deployed via apt
 * python based projects - history of experimental data analysis (researchy) rather 
   than production code. some of this needed to become production,
   so wanted things like productible builds rather than "well if I have exactly
   my laptop it runs" (not a criticism - its a genuine different in dev
   practice that needs interfacing)
 * other projects appearing ad-hoc in various combinations of languages
   - similar research prototype->production transitions need to be managed
       - even from people who are professional programmers, rather than
         PhDs

what is shake? it's a library for writing build systems, rather than
a command line tool called "shake".

Note that this isn't intended to be some canonical use of Shake - 
it's how it seemed to me to be a (not the) right way to do it.

Two uses of shake:

 *  the small one:
   took a small piece of the Makefile which was awkward and
   replaced it with shake.

  TODO: show the old code
  What was awkward about this?

  What couldn't we express in Make that we can express in shake?
  How did we express this in shake? 
    - show shake code
    - how it fits into Makefile - have to build shake each time or
       require it as a pre-req. this is cached though.

   -- extra feature - fast mode - different "function" that does the
      same thing (cp vs min, gzip -1 vs zopfli)

 * bigger use: buildosaurus.
    building "everything".
    on the TODO list to do "something" for a long time, but
     catalyst was new junior sys admin starting and me having
     to explain our processes - I decided I'd rather write it
     down in machine readable form rather than English.

    what are the kinds of things we're building?
      - debian packages
      - docker images
      - test "certifications" - describe this later

    this only happened in the last few weeks. payoffs so far:
      devs can build "official" style production releases on
      their machines. can re-use parts of CI/production infrastrucutre
      to stand up fuller test environments on their local
      machines.
   part of move towards a mono-repo -  change some docker file
     because we need a different compiler, for example, and
     we can version that together with the code that needs
     the different compiler (the monorepo part) and we can
     build without too much redundancy - this tool is helping us
     do that!

  catch all the bodges that we needed - eg not able to share
    ~/.stack,ghc,ghcjs between two of our components so we
    have to reroute; and makefile isn't expressive enough to
    give single-target builds.
    but now we have a codified place to describe those bodges
     and work on them rather than it being folklore about
      "oh delete your ~/.stack"

  we can start with a machine with docker on it and checkout
   repos, run a single build command, and it all builds (over
    many hours)

   TODO: a graph of all the components. parallelise with 
    modern shake so we can see parallelism? clean build on
    fresh AWS machine so no pollution

  using caches from  other tools: docker cache, .stack cache
    - these have different semantics - eg docker is content
        based, and can cope with multiple versons in cache at
       once, where shake's build directory approach is
         "either you have the current version or its invalid
          and we must rebuild". stack is slightly opaque and
         misbehaving sometimes.
    - don't get to control those so much. (downside)

  - oracles - what oracles implemented? review all

   test certifications - track which tests have run (at a
     big-chunk scale - because eg don't stand up a new DB every
     individual test )  
       - test certification file is a file generated to
          represent that the test passed - the "successful" output
          of the tets. imagine an IO operation that returns ()
          or errors. eithre you get the value because it passed
          or you don't.
      - can rebuild on things other than a source code change 
           - eg against latest database snapshot. this is "nothing
          special"  - just a regular dependency.

 shake criticisms - enough changes happening that I still want to
    pay attention to 'master' vs recent releases.

3. ghcjs vs ghc
     - generally very good
`
     - #ifdef build ickiness that I think can be almost
       entirely replaced - see my comment: 
       https://www.reddit.com/r/haskell/comments/56ucmt/how_do_you_structure_web_projects_that_share/d8n6xcj/
         - ocaml-Functor style types - an interesting variation on the "what text type to use?"
              - that only needs to be in one place, because we are constraining this to be
                parameterised over the whole build environment rather than mixing between
                projects.
             - actually have two different implementations of this, one in main app, one in
                  a library. ugh.
         - poor use of #ifdef to simulate files/modules/libraries.
         - config/package language not expressive enough (see later)

     - move away from talking about a "frontend" and a "backend" - it's
       single application running in a distributed environment where
       some components have one runtime and others have a different runtime.
        - version together, code together.
        - this works pretty well from my perspective (of disliking build being
          broken rather than having to code against it)
           . because we're in one language, we have type checked definition of
           how stuff moves between pieces of the app, liek we have type
           checked definition of how stuff moves between pieces of the app
           when making function calls.

     - spock+json to communicate - *BUT* this is not an "API"
        - move to shoving haskell data values around that are "command" objects
       . we serialise to JSON but
       we could serialise to anything. JSON is historical and
       I don't personally feel a huge pressure to move away from
       but it's not a core thing: most of our JSON is derive Generic,
       and we could derive another format.
       There is no "API" spec - these are communications within the
         same version of the app and by definition (or by type checking ;)
         will work together.

(aside:
     - separately there's a lot of REST-ish API interactions: 
        - we talk to third party services like facebook/instagram, openstreetmap
        - python/haskell components communicate over HTTP
)


 - cabal configure step for ghcjs modules runs in js - so in node (like TH)
    and so we call some of our preprocessing from in there as calls to Make
    from ghcjs FFI running in node.js
   (code sample here from the Setup.hs)
   - note the #ifdef

  - all these ifdefs hark back to writing multiplatform C code when I started as developer
     - they're expressing a thing that the language (haskell or C) doesn't express well
       so we need a DSL on the front of that to generate haskell appropriate for our 
       platform.

4. database testing / postgres subset tool

  - tool that didn't do what I want - take a big DB and
     output some subset of it that can be restored fast.
  - two kinds of fixpoints: SQL fixpoints - there is "expanding" sql fixpoint stuff but not "shrinking" style
                            Haskell mdo fixpoint - recursive value but need to grab information from other sources when doing it - from the config file for eg. overridden foreign keys, and from the database itself
  - url - "public" but no licence so you can't really use it. would like to fix that.
  - database subsetting as testing tool: giving a different database to the
    app that is not the mega-production-app database. so it should work. but sometimes
    it doesn't.

</pre>
</body>

</html>
